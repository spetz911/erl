<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Elegant XML SAX parsing using Erlang's pattern matching</title>
<script src='/nitrogen/jquery.js' type='text/javascript' charset='utf-8'></script>
<script src='/nitrogen/jquery-ui.js' type='text/javascript' charset='utf-8'></script>
<script src='/nitrogen/livevalidation.js' type='text/javascript' charset='utf-8'></script>
<script src='/nitrogen/nitrogen.js' type='text/javascript' charset='utf-8'></script>
<link rel="stylesheet" href="/nitrogen/nitrogen.css" />
<link rel="stylesheet" href="/css/grid.css" />
<link rel="stylesheet" href="/css/style.css" />

<!-- Prettify http://google-code-prettify.googlecode.com/ -->
<link href="/prettify/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="/prettify/prettify.js"></script>

<link href="/web/blog/atom.xml" type="application/atom+xml" rel="alternate" title="1011 Ltd Blog" />
</head>
<body onload="prettyPrint()">
  <div class="container_12">
    <div class="grid_8 alpha omega prefix_2 suffix_2 center">
      <a href="/"><img src="/images/banner.png" title="if you were wondering, my company logo is '1011ltd.com' encoded in 7-bit ASCII and reversed"/></a>
    </div>
    
    <div class="grid_8 alpha omega prefix_2 suffix_2 center">
      <div id="nav">
        <a href="/">About me</a>
        &middot;
        <a href="/web/blog/">blog</a>
        <a href="/web/blog/atom.xml"><img src="/images/Rss.png"
        alt="RSS"/></a>
        &middot;
        <a href="/projects">CV</a>
      </div>
      <div class="contacts">
        <a href="http://www.twitter.com/bjnortier">@bjnortier</a>
        &middot; 
        <a
        href="http://mailhide.recaptcha.net/d?k=01PasEPYmE_t6kmBMbiXUDJQ==&amp;c=3Ub-v4nUIk0_tRyM52mfOEvhMNefOfRvE5Q1FW0x-Kk="
        onclick="window.open('http://mailhide.recaptcha.net/d?k=01PasEPYmE_t6kmBMbiXUDJQ==&amp;c=3Ub-v4nUIk0_tRyM52mfOEvhMNefOfRvE5Q1FW0x-Kk=',
        '',
        'toolbar=0,scrollbars=0,location=0,statusbar=0,menubar=0,resizable=0,width=500,height=300');
        return false;" title="Reveal this e-mail address">email</a>
      </div>
   </div>
    
    <div class="flash_container wfid_temp209381 wfid_flash panel"></div>

    <div class="wfid_temp219380 container_12 panel"><div class="grid_8 alpha omega prefix_2 suffix_2 panel"><div class="wfid_temp219381 grid wfid_wfid_temp219381 panel"><div class="post-title wfid_temp219382 panel"><a href="/web/blog/post/elegant_xml_parsing" class="wfid_temp219383 link">Elegant XML SAX parsing using Erlang's pattern matching</a></div><span class="date-posted wfid_temp219384">Thu, 24 Jun 2010</span>&nbsp;<script>var idcomments_acct = '6638827fddfffd4b3c59f0b748ef7bca';var idcomments_post_id;var idcomments_post_url;</script><script type='text/javascript' src='http://www.intensedebate.com/js/genericLinkWrapperV2.js'></script><div class="right-float tag-cloud wfid_temp219385 panel"><span class="title wfid_temp219386">tagged with</span><ul class="wfid_temp219387 list"><li class="wfid_temp219388 listitem"><a href="/web/blog/tag/Erlang" class="wfid_temp219389 link">Erlang</a></li><li class="wfid_temp219390 listitem"><a href="/web/blog/tag/XML" class="wfid_temp219391 link">XML</a></li><li class="wfid_temp219392 listitem"><a href="/web/blog/tag/SAX parser" class="wfid_temp219393 link">SAX parser</a></li></ul></div><div class="post-content wfid_temp219394 panel"><p>
Yesterday I wrote some code for parsing an XML file with Erlang's built-in SAX parser. It turned out that the events generated by the SAX
parser, combined with the pattern matching in Erlang yielded a really elegant solution. 
</p>

<!-- end summary -->

<p>
I'm building a financial information website that is focussed on commodities, so I want to display some graphs
with historical commodity prices. There a great source of financial information, <a href="http://www.xignite.com/">Xignite</a>, which is a paid service that
offers good APIs (include REST) to obtain market data. The data is delivered in XML format.
</p>

<p>
Here's an extract of the XML for the Gold future price:
</p>

<pre class="prettyprint">
    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;FutureQuotes &hellip; &gt;
      &hellip;
      &lt;Quotes&gt;
	&lt;FutureQuote&gt;
	  &hellip;
	  &lt;Date&gt;6/22/2010&lt;/Date&gt;
	  &lt;Open&gt;1234.03&lt;/Open&gt;
	  &lt;High&gt;1242.6&lt;/High&gt;
	  &lt;Low&gt;1231.3&lt;/Low&gt;
	  &lt;Last&gt;1239.9&lt;/Last&gt;
	  &lt;Settle&gt;1239.9&lt;/Settle&gt;
	  &lt;Volume&gt;0&lt;/Volume&gt;
	  &lt;OpenInterest&gt;0&lt;/OpenInterest&gt;
	  &lt;PreviousClose&gt;1233.59&lt;/PreviousClose&gt;
	  &lt;Change&gt;6.31&lt;/Change&gt;
	  &lt;PercentChange&gt;0.512&lt;/PercentChange&gt;
	  &lt;Currency&gt;USD&lt;/Currency&gt;
	&lt;/FutureQuote&gt;
	&lt;FutureQuote&gt;
	  &hellip;
	&lt;/FutureQuote&gt;
      &lt;/Quotes&gt;
    &lt;/FutureQuotes&gt;
</pre>

<br/>
<p>
The elements that I'm interested in at this point are &quot;Date&quot;, &quot;Open&quot;, &quot;High&quot;,  &quot;Low&quot; and &quot;Last&quot;.
Let's see what happens when we throw the built-in SAX parser at it:
</p>

<pre class="prettyprint">
  xmerl_sax_parser:file(
      "data/test.xml", 
      [{event_fun, fun(Event, _Location, _State) ->
			   io:format("~p~n", [Event])
		   end}]).
</pre>

<br/>
<p>The code above simple means &quot;Parse this XML file with the SAX parser and use this anonymous function every time an event is generated&quot;.
You will notice below how the SAX parser generates events for each start and end element, characters and ignorable white space:
</p>

<pre class="prettyprint">
&hellip;
{startElement,"http://www.xignite.com/services/","Date",{[],"Date"},[]}
{characters,"12/6/2006"}
{endElement,"http://www.xignite.com/services/","Date",{[],"Date"}}
{ignorableWhitespace,"\n      "}
{startElement,"http://www.xignite.com/services/","Open",{[],"Open"},[]}
{characters,"62.2"}
{endElement,"http://www.xignite.com/services/","Open",{[],"Open"}}
{ignorableWhitespace,"\n      "}
{startElement,"http://www.xignite.com/services/","High",{[],"High"},[]}
{characters,"62.2"}
{endElement,"http://www.xignite.com/services/","High",{[],"High"}}
{ignorableWhitespace,"\n      "}
{startElement,"http://www.xignite.com/services/","Low",{[],"Low"},[]}
{characters,"62.2"}
{endElement,"http://www.xignite.com/services/","Low",{[],"Low"}}
{ignorableWhitespace,"\n      "}
&hellip;
</pre>

<br/>
<p>
Now I'll show you how I extracted the &quot;Date&quot; value for each quote into a list of key-value pairs. I've added the initial event state
to the parser, which is a tuple with two elements. The first element will be the list of quotes (as key-value tuples), and the second element will contain 
the last set of parsed characters (initially an empty string/list);
</p>

<pre class="prettyprint">
run(FileName) ->
    {ok, {Quotes, _}, _} = xmerl_sax_parser:file(
			     FileName, 
			     [{event_fun, fun event/3},
			      {event_state, {[], ""}}]),
    Quotes.
</pre>

<br/>
<p>
For the start elements, I'm interested in the "FutureQuote" element. When this element is encountered,
I add a new, empty set of key-value pairs to the existing list of quotes. The second element of the state remains an empty
string (the return value from the event function is the new state):
</p>

<pre class="prettyprint">
%% Start "FutureQuote" creates a new, empty key-value list
%% for the quote
event(_Event = {startElement, _, "FutureQuote", _, _}, 
      _Location, 
      _State = {Quotes, _}) ->
    {[[]|Quotes], ""};
</pre>

<br/>
<p>
When the &quot;characters&quot; element is encountered, we store it in the second element of the parser state:
</p>

<pre class="prettyprint">
%% Characters are stores in the parser state
event(_Event = {characters, Chars}, 
      _Location, 
      _State = {Quotes, _}) ->
    {Quotes, Chars};
</pre>

<br/>
<p>
Now, when we encounter the end element of the &quot;Date&quot; tag, the parser state will
have the last encounter characters as the second element. So we add that as the key-value
pair to the quote at the head of the list:
</p>

<pre class="prettyprint">
%% For the "Date" event, use the last set of characters encountered
%% for the "Date" property
event(_Event = {endElement, _, "Date", _}, 
      _Location, 
      _State = {[Quote|Rest], Chars}) ->
    Updated = [{"Date", Chars}|Quote],
    {[Updated|Rest], undefined};
</pre>

<br/>
<p>
Finally, for all other events, we just pass on the current state:
</p>

<pre class="prettyprint">
%% Catch-all. Pass state on as-is    
event(_Event, _Location, State) ->
    State.
</pre>

<br/>
<p>
And now when I run this against the test XML file containing two quotes, the result is a 
list of key-value pairs with the &quot;Date&quot; values:
</p>

<pre class="prettyprint">
1> populate1:run("data/test.xml").
[[{"Date","12/6/2006"}],[{"Date","12/7/2006"}]]
</pre>

<br/>
<p>
Almost there! The last step is to generalise the elements we are interesed in with a macro. I'm using a macro
because it allows me to use the pattern matching directly in the function definitions, as opposed to examining a list
of fields of interest on each event. Here we go with the complete module:
</p>

<pre class="prettyprint">
-module(populate).
-export([run/1]).

run(FileName) ->
    {ok, {Quotes, _}, _} = xmerl_sax_parser:file(
			     FileName, 
			     [{event_fun, fun event/3},
			      {event_state, {[], ""}}]),
    Quotes.

%% For the end field event, use the last set of characters 
%% encountered as the value for that field
-define(QUOTE_VALUE(Title),
	event(_Event = {endElement, _, Title, _}, 
	      _Location, 
	      _State = {[Quote|Rest], Chars}) ->
	       Updated = [{Title, Chars}|Quote],
	       {[Updated|Rest], undefined}).


%% Start "FutureQuote" creates a new, empty key-value list
%% for the quote
event(_Event = {startElement, _, "FutureQuote", _, _}, 
      _Location, 
      _State = {Quotes, _}) ->
    {[[]|Quotes], ""};

%% Characters are stores in the parser state
event(_Event = {characters, Chars}, 
      _Location, 
      _State = {Quotes, _}) ->
    {Quotes, Chars};

?QUOTE_VALUE("Date");
?QUOTE_VALUE("Open");
?QUOTE_VALUE("High");
?QUOTE_VALUE("Low");
?QUOTE_VALUE("Last");

%% Catch-all. Pass state on as-is    
event(_Event, _Location, State) ->
    State.
</pre>

<br/>
<p>
And the result:
</p>

<pre class="prettyprint">
2> populate:run("data/test.xml").
[[{"Last","62.2"},
  {"Low","62.2"},
  {"High","62.2"},
  {"Open","62.2"},
  {"Date","12/6/2006"}],
 [{"Last","62.5"},
  {"Low","62.5"},
  {"High","62.5"},
  {"Open","62.5"},
  {"Date","12/7/2006"}]]
</pre>

<br/>
<p>
Voila! I hope that if you love pattern matching, you're nodding. And if you don't (yet), that you try it out for yourself. 
There are situations such as this where it enables you to write very elegant and maintainable code. But be warned, you'll
never want to program without it again!
</p>
</div></div></div><div class='clear'></div>
</div>

    <div class="grid_8 alpha omega prefix_2 suffix_2 center">
    <hr class='comment-sep'/><script>var idcomments_acct = '6638827fddfffd4b3c59f0b748ef7bca';var idcomments_post_id;var idcomments_post_url;</script><span id='IDCommentsPostTitle' style='display:none'></span><script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
    </div>

    <div class="center" id="footer">
      <!--Powered by 
      <a href="http://nitrogenproject.com/">Nitrogen</a>
      <img
      src="http://nitrogenproject.com/images/MiniSpaceman.png"/>-->
      
    </div>

    <script>
      Nitrogen.$set_param('pageContext', 'XSJ3sINQAAADwnichZLLTsMwEEWHlCzog1YqoLLiGyo25VNYWY49sV0cO9iOaL-E3yWRSJtX5Z11T3xmbmSZaABIZMphWVKBhFkT8BS-YB6wKPeHj_fDnsPqBzOSaStIaX0Nt6hRUBPIqdCkpM4rIzikzBYYGuGiEa4lNVyja50cHutTrgT5BxxeOOa00oEMwUNlaqQM8uO0atEsc_l823p6aVSyK51l6D1xKJQP7ny9-2oaVucTLOpdMcokXi88X2r287jou8Lu5ItokEdFa1_XVNZ0fr1XRamRjEB8KR9omGo3yK-i5kncyaSOJPUk19RLDvfBVXhjxEZxNEGFTsVdO2WMohsvndWdxZ5aVT-OF3e26hc_G1ooRgZ5VLTxyCo3XW-MOrrjUc4ygPQtg_nmN4PZZ_oH3XtVvg');

    </script>

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-3627253-5");
    pageTracker._trackPageview();
    } catch(err) {}
    </script>

  </div>
</body>
</html>
